// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: thorchain/v1/x/thorchain/types/type_events.proto

package types

import (
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	common "gitlab.com/thorchain/thornode/common"
	gitlab_com_thorchain_thornode_common "gitlab.com/thorchain/thornode/common"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type BondType int32

const (
	BondType_bond_paid     BondType = 0
	BondType_bond_returned BondType = 1
)

var BondType_name = map[int32]string{
	0: "bond_paid",
	1: "bond_returned",
}

var BondType_value = map[string]int32{
	"bond_paid":     0,
	"bond_returned": 1,
}

func (x BondType) String() string {
	return proto.EnumName(BondType_name, int32(x))
}

func (BondType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{0}
}

type PoolMod struct {
	Asset    common.Asset                            `protobuf:"bytes,1,opt,name=asset,proto3" json:"asset"`
	RuneAmt  github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,2,opt,name=rune_amt,json=runeAmt,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"rune_amt"`
	RuneAdd  bool                                    `protobuf:"varint,3,opt,name=rune_add,json=runeAdd,proto3" json:"rune_add,omitempty"`
	AssetAmt github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,4,opt,name=asset_amt,json=assetAmt,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"asset_amt"`
	AssetAdd bool                                    `protobuf:"varint,5,opt,name=asset_add,json=assetAdd,proto3" json:"asset_add,omitempty"`
}

func (m *PoolMod) Reset()         { *m = PoolMod{} }
func (m *PoolMod) String() string { return proto.CompactTextString(m) }
func (*PoolMod) ProtoMessage()    {}
func (*PoolMod) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{0}
}
func (m *PoolMod) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolMod) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolMod.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolMod) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolMod.Merge(m, src)
}
func (m *PoolMod) XXX_Size() int {
	return m.Size()
}
func (m *PoolMod) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolMod.DiscardUnknown(m)
}

var xxx_messageInfo_PoolMod proto.InternalMessageInfo

func (m *PoolMod) GetAsset() common.Asset {
	if m != nil {
		return m.Asset
	}
	return common.Asset{}
}

func (m *PoolMod) GetRuneAdd() bool {
	if m != nil {
		return m.RuneAdd
	}
	return false
}

func (m *PoolMod) GetAssetAdd() bool {
	if m != nil {
		return m.AssetAdd
	}
	return false
}

type EventSwap struct {
	Pool               common.Asset                            `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool"`
	SwapTarget         github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,2,opt,name=swap_target,json=swapTarget,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"swap_target"`
	SwapSlip           github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,3,opt,name=swap_slip,json=swapSlip,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"swap_slip"`
	LiquidityFee       github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,4,opt,name=liquidity_fee,json=liquidityFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"liquidity_fee"`
	LiquidityFeeInRune github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,5,opt,name=liquidity_fee_in_rune,json=liquidityFeeInRune,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"liquidity_fee_in_rune"`
	InTx               common.Tx                               `protobuf:"bytes,6,opt,name=in_tx,json=inTx,proto3" json:"in_tx"`
	OutTxs             common.Tx                               `protobuf:"bytes,7,opt,name=out_txs,json=outTxs,proto3" json:"out_txs"`
	EmitAsset          common.Coin                             `protobuf:"bytes,8,opt,name=emit_asset,json=emitAsset,proto3" json:"emit_asset"`
	SynthUnits         github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,9,opt,name=synth_units,json=synthUnits,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"synth_units"`
}

func (m *EventSwap) Reset()         { *m = EventSwap{} }
func (m *EventSwap) String() string { return proto.CompactTextString(m) }
func (*EventSwap) ProtoMessage()    {}
func (*EventSwap) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{1}
}
func (m *EventSwap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSwap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSwap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSwap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSwap.Merge(m, src)
}
func (m *EventSwap) XXX_Size() int {
	return m.Size()
}
func (m *EventSwap) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSwap.DiscardUnknown(m)
}

var xxx_messageInfo_EventSwap proto.InternalMessageInfo

func (m *EventSwap) GetPool() common.Asset {
	if m != nil {
		return m.Pool
	}
	return common.Asset{}
}

func (m *EventSwap) GetInTx() common.Tx {
	if m != nil {
		return m.InTx
	}
	return common.Tx{}
}

func (m *EventSwap) GetOutTxs() common.Tx {
	if m != nil {
		return m.OutTxs
	}
	return common.Tx{}
}

func (m *EventSwap) GetEmitAsset() common.Coin {
	if m != nil {
		return m.EmitAsset
	}
	return common.Coin{}
}

type EventAddLiquidity struct {
	Pool          common.Asset                                 `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool"`
	ProviderUnits github_com_cosmos_cosmos_sdk_types.Uint      `protobuf:"bytes,2,opt,name=provider_units,json=providerUnits,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"provider_units"`
	RuneAddress   gitlab_com_thorchain_thornode_common.Address `protobuf:"bytes,3,opt,name=rune_address,json=runeAddress,proto3,casttype=gitlab.com/thorchain/thornode/common.Address" json:"rune_address,omitempty"`
	RuneAmount    github_com_cosmos_cosmos_sdk_types.Uint      `protobuf:"bytes,4,opt,name=rune_amount,json=runeAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"rune_amount"`
	AssetAmount   github_com_cosmos_cosmos_sdk_types.Uint      `protobuf:"bytes,5,opt,name=asset_amount,json=assetAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"asset_amount"`
	RuneTxID      gitlab_com_thorchain_thornode_common.TxID    `protobuf:"bytes,6,opt,name=rune_tx_id,json=runeTxId,proto3,casttype=gitlab.com/thorchain/thornode/common.TxID" json:"rune_tx_id,omitempty"`
	AssetTxID     gitlab_com_thorchain_thornode_common.TxID    `protobuf:"bytes,7,opt,name=asset_tx_id,json=assetTxId,proto3,casttype=gitlab.com/thorchain/thornode/common.TxID" json:"asset_tx_id,omitempty"`
	AssetAddress  gitlab_com_thorchain_thornode_common.Address `protobuf:"bytes,8,opt,name=asset_address,json=assetAddress,proto3,casttype=gitlab.com/thorchain/thornode/common.Address" json:"asset_address,omitempty"`
}

func (m *EventAddLiquidity) Reset()         { *m = EventAddLiquidity{} }
func (m *EventAddLiquidity) String() string { return proto.CompactTextString(m) }
func (*EventAddLiquidity) ProtoMessage()    {}
func (*EventAddLiquidity) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{2}
}
func (m *EventAddLiquidity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAddLiquidity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAddLiquidity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAddLiquidity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAddLiquidity.Merge(m, src)
}
func (m *EventAddLiquidity) XXX_Size() int {
	return m.Size()
}
func (m *EventAddLiquidity) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAddLiquidity.DiscardUnknown(m)
}

var xxx_messageInfo_EventAddLiquidity proto.InternalMessageInfo

func (m *EventAddLiquidity) GetPool() common.Asset {
	if m != nil {
		return m.Pool
	}
	return common.Asset{}
}

func (m *EventAddLiquidity) GetRuneAddress() gitlab_com_thorchain_thornode_common.Address {
	if m != nil {
		return m.RuneAddress
	}
	return ""
}

func (m *EventAddLiquidity) GetRuneTxID() gitlab_com_thorchain_thornode_common.TxID {
	if m != nil {
		return m.RuneTxID
	}
	return ""
}

func (m *EventAddLiquidity) GetAssetTxID() gitlab_com_thorchain_thornode_common.TxID {
	if m != nil {
		return m.AssetTxID
	}
	return ""
}

func (m *EventAddLiquidity) GetAssetAddress() gitlab_com_thorchain_thornode_common.Address {
	if m != nil {
		return m.AssetAddress
	}
	return ""
}

type EventWithdraw struct {
	Pool              common.Asset                            `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool"`
	ProviderUnits     github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,2,opt,name=provider_units,json=providerUnits,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"provider_units"`
	BasisPoints       int64                                   `protobuf:"varint,3,opt,name=basis_points,json=basisPoints,proto3" json:"basis_points,omitempty"`
	Asymmetry         github_com_cosmos_cosmos_sdk_types.Dec  `protobuf:"bytes,4,opt,name=asymmetry,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"asymmetry"`
	InTx              common.Tx                               `protobuf:"bytes,5,opt,name=in_tx,json=inTx,proto3" json:"in_tx"`
	EmitAsset         github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,6,opt,name=emit_asset,json=emitAsset,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"emit_asset"`
	EmitRune          github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,7,opt,name=emit_rune,json=emitRune,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"emit_rune"`
	ImpLossProtection github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,8,opt,name=imp_loss_protection,json=impLossProtection,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"imp_loss_protection"`
}

func (m *EventWithdraw) Reset()         { *m = EventWithdraw{} }
func (m *EventWithdraw) String() string { return proto.CompactTextString(m) }
func (*EventWithdraw) ProtoMessage()    {}
func (*EventWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{3}
}
func (m *EventWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventWithdraw.Merge(m, src)
}
func (m *EventWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *EventWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_EventWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_EventWithdraw proto.InternalMessageInfo

func (m *EventWithdraw) GetPool() common.Asset {
	if m != nil {
		return m.Pool
	}
	return common.Asset{}
}

func (m *EventWithdraw) GetBasisPoints() int64 {
	if m != nil {
		return m.BasisPoints
	}
	return 0
}

func (m *EventWithdraw) GetInTx() common.Tx {
	if m != nil {
		return m.InTx
	}
	return common.Tx{}
}

type EventDonate struct {
	Pool common.Asset `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool"`
	InTx common.Tx    `protobuf:"bytes,2,opt,name=in_tx,json=inTx,proto3" json:"in_tx"`
}

func (m *EventDonate) Reset()         { *m = EventDonate{} }
func (m *EventDonate) String() string { return proto.CompactTextString(m) }
func (*EventDonate) ProtoMessage()    {}
func (*EventDonate) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{4}
}
func (m *EventDonate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventDonate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventDonate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventDonate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventDonate.Merge(m, src)
}
func (m *EventDonate) XXX_Size() int {
	return m.Size()
}
func (m *EventDonate) XXX_DiscardUnknown() {
	xxx_messageInfo_EventDonate.DiscardUnknown(m)
}

var xxx_messageInfo_EventDonate proto.InternalMessageInfo

func (m *EventDonate) GetPool() common.Asset {
	if m != nil {
		return m.Pool
	}
	return common.Asset{}
}

func (m *EventDonate) GetInTx() common.Tx {
	if m != nil {
		return m.InTx
	}
	return common.Tx{}
}

type EventPool struct {
	Pool   common.Asset `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool"`
	Status PoolStatus   `protobuf:"varint,2,opt,name=Status,proto3,enum=types.PoolStatus" json:"Status,omitempty"`
}

func (m *EventPool) Reset()         { *m = EventPool{} }
func (m *EventPool) String() string { return proto.CompactTextString(m) }
func (*EventPool) ProtoMessage()    {}
func (*EventPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{5}
}
func (m *EventPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPool.Merge(m, src)
}
func (m *EventPool) XXX_Size() int {
	return m.Size()
}
func (m *EventPool) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPool.DiscardUnknown(m)
}

var xxx_messageInfo_EventPool proto.InternalMessageInfo

func (m *EventPool) GetPool() common.Asset {
	if m != nil {
		return m.Pool
	}
	return common.Asset{}
}

func (m *EventPool) GetStatus() PoolStatus {
	if m != nil {
		return m.Status
	}
	return PoolStatus_UnknownPoolStatus
}

type PoolAmt struct {
	Asset  common.Asset `protobuf:"bytes,1,opt,name=asset,proto3" json:"asset"`
	Amount int64        `protobuf:"varint,2,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *PoolAmt) Reset()         { *m = PoolAmt{} }
func (m *PoolAmt) String() string { return proto.CompactTextString(m) }
func (*PoolAmt) ProtoMessage()    {}
func (*PoolAmt) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{6}
}
func (m *PoolAmt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolAmt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolAmt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolAmt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolAmt.Merge(m, src)
}
func (m *PoolAmt) XXX_Size() int {
	return m.Size()
}
func (m *PoolAmt) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolAmt.DiscardUnknown(m)
}

var xxx_messageInfo_PoolAmt proto.InternalMessageInfo

func (m *PoolAmt) GetAsset() common.Asset {
	if m != nil {
		return m.Asset
	}
	return common.Asset{}
}

func (m *PoolAmt) GetAmount() int64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

type EventRewards struct {
	BondReward  github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,1,opt,name=bond_reward,json=bondReward,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"bond_reward"`
	PoolRewards []PoolAmt                               `protobuf:"bytes,2,rep,name=pool_rewards,json=poolRewards,proto3" json:"pool_rewards"`
}

func (m *EventRewards) Reset()         { *m = EventRewards{} }
func (m *EventRewards) String() string { return proto.CompactTextString(m) }
func (*EventRewards) ProtoMessage()    {}
func (*EventRewards) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{7}
}
func (m *EventRewards) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventRewards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventRewards.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventRewards) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventRewards.Merge(m, src)
}
func (m *EventRewards) XXX_Size() int {
	return m.Size()
}
func (m *EventRewards) XXX_DiscardUnknown() {
	xxx_messageInfo_EventRewards.DiscardUnknown(m)
}

var xxx_messageInfo_EventRewards proto.InternalMessageInfo

func (m *EventRewards) GetPoolRewards() []PoolAmt {
	if m != nil {
		return m.PoolRewards
	}
	return nil
}

type EventRefund struct {
	Code   uint32     `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Reason string     `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	InTx   common.Tx  `protobuf:"bytes,3,opt,name=in_tx,json=inTx,proto3" json:"in_tx"`
	Fee    common.Fee `protobuf:"bytes,4,opt,name=fee,proto3" json:"fee"`
}

func (m *EventRefund) Reset()         { *m = EventRefund{} }
func (m *EventRefund) String() string { return proto.CompactTextString(m) }
func (*EventRefund) ProtoMessage()    {}
func (*EventRefund) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{8}
}
func (m *EventRefund) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventRefund) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventRefund.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventRefund) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventRefund.Merge(m, src)
}
func (m *EventRefund) XXX_Size() int {
	return m.Size()
}
func (m *EventRefund) XXX_DiscardUnknown() {
	xxx_messageInfo_EventRefund.DiscardUnknown(m)
}

var xxx_messageInfo_EventRefund proto.InternalMessageInfo

func (m *EventRefund) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *EventRefund) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *EventRefund) GetInTx() common.Tx {
	if m != nil {
		return m.InTx
	}
	return common.Tx{}
}

func (m *EventRefund) GetFee() common.Fee {
	if m != nil {
		return m.Fee
	}
	return common.Fee{}
}

type EventBond struct {
	Amount   github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,1,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"amount"`
	BondType BondType                                `protobuf:"varint,2,opt,name=bond_type,json=bondType,proto3,enum=types.BondType" json:"bond_type,omitempty"`
	TxIn     common.Tx                               `protobuf:"bytes,3,opt,name=tx_in,json=txIn,proto3" json:"tx_in"`
}

func (m *EventBond) Reset()         { *m = EventBond{} }
func (m *EventBond) String() string { return proto.CompactTextString(m) }
func (*EventBond) ProtoMessage()    {}
func (*EventBond) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{9}
}
func (m *EventBond) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBond) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBond.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBond) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBond.Merge(m, src)
}
func (m *EventBond) XXX_Size() int {
	return m.Size()
}
func (m *EventBond) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBond.DiscardUnknown(m)
}

var xxx_messageInfo_EventBond proto.InternalMessageInfo

func (m *EventBond) GetBondType() BondType {
	if m != nil {
		return m.BondType
	}
	return BondType_bond_paid
}

func (m *EventBond) GetTxIn() common.Tx {
	if m != nil {
		return m.TxIn
	}
	return common.Tx{}
}

type GasPool struct {
	Asset    common.Asset                            `protobuf:"bytes,1,opt,name=asset,proto3" json:"asset"`
	RuneAmt  github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,2,opt,name=rune_amt,json=runeAmt,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"rune_amt"`
	AssetAmt github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,3,opt,name=asset_amt,json=assetAmt,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"asset_amt"`
	Count    int64                                   `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *GasPool) Reset()         { *m = GasPool{} }
func (m *GasPool) String() string { return proto.CompactTextString(m) }
func (*GasPool) ProtoMessage()    {}
func (*GasPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{10}
}
func (m *GasPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GasPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GasPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GasPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GasPool.Merge(m, src)
}
func (m *GasPool) XXX_Size() int {
	return m.Size()
}
func (m *GasPool) XXX_DiscardUnknown() {
	xxx_messageInfo_GasPool.DiscardUnknown(m)
}

var xxx_messageInfo_GasPool proto.InternalMessageInfo

func (m *GasPool) GetAsset() common.Asset {
	if m != nil {
		return m.Asset
	}
	return common.Asset{}
}

func (m *GasPool) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type EventGas struct {
	Pools []GasPool `protobuf:"bytes,1,rep,name=pools,proto3" json:"pools"`
}

func (m *EventGas) Reset()         { *m = EventGas{} }
func (m *EventGas) String() string { return proto.CompactTextString(m) }
func (*EventGas) ProtoMessage()    {}
func (*EventGas) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{11}
}
func (m *EventGas) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventGas) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventGas.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventGas) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventGas.Merge(m, src)
}
func (m *EventGas) XXX_Size() int {
	return m.Size()
}
func (m *EventGas) XXX_DiscardUnknown() {
	xxx_messageInfo_EventGas.DiscardUnknown(m)
}

var xxx_messageInfo_EventGas proto.InternalMessageInfo

func (m *EventGas) GetPools() []GasPool {
	if m != nil {
		return m.Pools
	}
	return nil
}

type EventReserve struct {
	ReserveContributor ReserveContributor `protobuf:"bytes,1,opt,name=reserve_contributor,json=reserveContributor,proto3" json:"reserve_contributor"`
	InTx               common.Tx          `protobuf:"bytes,2,opt,name=in_tx,json=inTx,proto3" json:"in_tx"`
}

func (m *EventReserve) Reset()         { *m = EventReserve{} }
func (m *EventReserve) String() string { return proto.CompactTextString(m) }
func (*EventReserve) ProtoMessage()    {}
func (*EventReserve) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{12}
}
func (m *EventReserve) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventReserve) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventReserve.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventReserve) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventReserve.Merge(m, src)
}
func (m *EventReserve) XXX_Size() int {
	return m.Size()
}
func (m *EventReserve) XXX_DiscardUnknown() {
	xxx_messageInfo_EventReserve.DiscardUnknown(m)
}

var xxx_messageInfo_EventReserve proto.InternalMessageInfo

func (m *EventReserve) GetReserveContributor() ReserveContributor {
	if m != nil {
		return m.ReserveContributor
	}
	return ReserveContributor{}
}

func (m *EventReserve) GetInTx() common.Tx {
	if m != nil {
		return m.InTx
	}
	return common.Tx{}
}

type EventSlash struct {
	Pool        common.Asset `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool"`
	SlashAmount []PoolAmt    `protobuf:"bytes,2,rep,name=slash_amount,json=slashAmount,proto3" json:"slash_amount"`
}

func (m *EventSlash) Reset()         { *m = EventSlash{} }
func (m *EventSlash) String() string { return proto.CompactTextString(m) }
func (*EventSlash) ProtoMessage()    {}
func (*EventSlash) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{13}
}
func (m *EventSlash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSlash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSlash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSlash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSlash.Merge(m, src)
}
func (m *EventSlash) XXX_Size() int {
	return m.Size()
}
func (m *EventSlash) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSlash.DiscardUnknown(m)
}

var xxx_messageInfo_EventSlash proto.InternalMessageInfo

func (m *EventSlash) GetPool() common.Asset {
	if m != nil {
		return m.Pool
	}
	return common.Asset{}
}

func (m *EventSlash) GetSlashAmount() []PoolAmt {
	if m != nil {
		return m.SlashAmount
	}
	return nil
}

type EventErrata struct {
	TxID  gitlab_com_thorchain_thornode_common.TxID `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/common.TxID" json:"tx_id,omitempty"`
	Pools PoolMods                                  `protobuf:"bytes,2,rep,name=pools,proto3,castrepeated=PoolMods" json:"pools"`
}

func (m *EventErrata) Reset()         { *m = EventErrata{} }
func (m *EventErrata) String() string { return proto.CompactTextString(m) }
func (*EventErrata) ProtoMessage()    {}
func (*EventErrata) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{14}
}
func (m *EventErrata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventErrata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventErrata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventErrata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventErrata.Merge(m, src)
}
func (m *EventErrata) XXX_Size() int {
	return m.Size()
}
func (m *EventErrata) XXX_DiscardUnknown() {
	xxx_messageInfo_EventErrata.DiscardUnknown(m)
}

var xxx_messageInfo_EventErrata proto.InternalMessageInfo

func (m *EventErrata) GetTxID() gitlab_com_thorchain_thornode_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

func (m *EventErrata) GetPools() PoolMods {
	if m != nil {
		return m.Pools
	}
	return nil
}

type EventFee struct {
	TxID       gitlab_com_thorchain_thornode_common.TxID `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/common.TxID" json:"tx_id,omitempty"`
	Fee        common.Fee                                `protobuf:"bytes,2,opt,name=fee,proto3" json:"fee"`
	SynthUnits github_com_cosmos_cosmos_sdk_types.Uint   `protobuf:"bytes,3,opt,name=synth_units,json=synthUnits,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"synth_units"`
}

func (m *EventFee) Reset()         { *m = EventFee{} }
func (m *EventFee) String() string { return proto.CompactTextString(m) }
func (*EventFee) ProtoMessage()    {}
func (*EventFee) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{15}
}
func (m *EventFee) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventFee) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventFee.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventFee) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventFee.Merge(m, src)
}
func (m *EventFee) XXX_Size() int {
	return m.Size()
}
func (m *EventFee) XXX_DiscardUnknown() {
	xxx_messageInfo_EventFee.DiscardUnknown(m)
}

var xxx_messageInfo_EventFee proto.InternalMessageInfo

func (m *EventFee) GetTxID() gitlab_com_thorchain_thornode_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

func (m *EventFee) GetFee() common.Fee {
	if m != nil {
		return m.Fee
	}
	return common.Fee{}
}

type EventOutbound struct {
	InTxID gitlab_com_thorchain_thornode_common.TxID `protobuf:"bytes,1,opt,name=in_tx_id,json=inTxId,proto3,casttype=gitlab.com/thorchain/thornode/common.TxID" json:"in_tx_id,omitempty"`
	Tx     common.Tx                                 `protobuf:"bytes,2,opt,name=tx,proto3" json:"tx"`
}

func (m *EventOutbound) Reset()         { *m = EventOutbound{} }
func (m *EventOutbound) String() string { return proto.CompactTextString(m) }
func (*EventOutbound) ProtoMessage()    {}
func (*EventOutbound) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{16}
}
func (m *EventOutbound) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOutbound) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOutbound.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOutbound) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOutbound.Merge(m, src)
}
func (m *EventOutbound) XXX_Size() int {
	return m.Size()
}
func (m *EventOutbound) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOutbound.DiscardUnknown(m)
}

var xxx_messageInfo_EventOutbound proto.InternalMessageInfo

func (m *EventOutbound) GetInTxID() gitlab_com_thorchain_thornode_common.TxID {
	if m != nil {
		return m.InTxID
	}
	return ""
}

func (m *EventOutbound) GetTx() common.Tx {
	if m != nil {
		return m.Tx
	}
	return common.Tx{}
}

type EventTssKeygenMetric struct {
	PubKey           gitlab_com_thorchain_thornode_common.PubKey `protobuf:"bytes,1,opt,name=pub_key,json=pubKey,proto3,casttype=gitlab.com/thorchain/thornode/common.PubKey" json:"pub_key,omitempty"`
	MedianDurationMs int64                                       `protobuf:"varint,2,opt,name=median_duration_ms,json=medianDurationMs,proto3" json:"median_duration_ms,omitempty"`
}

func (m *EventTssKeygenMetric) Reset()         { *m = EventTssKeygenMetric{} }
func (m *EventTssKeygenMetric) String() string { return proto.CompactTextString(m) }
func (*EventTssKeygenMetric) ProtoMessage()    {}
func (*EventTssKeygenMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{17}
}
func (m *EventTssKeygenMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTssKeygenMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTssKeygenMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTssKeygenMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTssKeygenMetric.Merge(m, src)
}
func (m *EventTssKeygenMetric) XXX_Size() int {
	return m.Size()
}
func (m *EventTssKeygenMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTssKeygenMetric.DiscardUnknown(m)
}

var xxx_messageInfo_EventTssKeygenMetric proto.InternalMessageInfo

func (m *EventTssKeygenMetric) GetPubKey() gitlab_com_thorchain_thornode_common.PubKey {
	if m != nil {
		return m.PubKey
	}
	return ""
}

func (m *EventTssKeygenMetric) GetMedianDurationMs() int64 {
	if m != nil {
		return m.MedianDurationMs
	}
	return 0
}

type EventTssKeysignMetric struct {
	TxID             gitlab_com_thorchain_thornode_common.TxID `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/common.TxID" json:"tx_id,omitempty"`
	MedianDurationMs int64                                     `protobuf:"varint,2,opt,name=median_duration_ms,json=medianDurationMs,proto3" json:"median_duration_ms,omitempty"`
}

func (m *EventTssKeysignMetric) Reset()         { *m = EventTssKeysignMetric{} }
func (m *EventTssKeysignMetric) String() string { return proto.CompactTextString(m) }
func (*EventTssKeysignMetric) ProtoMessage()    {}
func (*EventTssKeysignMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{18}
}
func (m *EventTssKeysignMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTssKeysignMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTssKeysignMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTssKeysignMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTssKeysignMetric.Merge(m, src)
}
func (m *EventTssKeysignMetric) XXX_Size() int {
	return m.Size()
}
func (m *EventTssKeysignMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTssKeysignMetric.DiscardUnknown(m)
}

var xxx_messageInfo_EventTssKeysignMetric proto.InternalMessageInfo

func (m *EventTssKeysignMetric) GetTxID() gitlab_com_thorchain_thornode_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

func (m *EventTssKeysignMetric) GetMedianDurationMs() int64 {
	if m != nil {
		return m.MedianDurationMs
	}
	return 0
}

type EventSlashPoint struct {
	NodeAddress github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=node_address,json=nodeAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"node_address,omitempty"`
	SlashPoints int64                                         `protobuf:"varint,2,opt,name=slash_points,json=slashPoints,proto3" json:"slash_points,omitempty"`
	Reason      string                                        `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *EventSlashPoint) Reset()         { *m = EventSlashPoint{} }
func (m *EventSlashPoint) String() string { return proto.CompactTextString(m) }
func (*EventSlashPoint) ProtoMessage()    {}
func (*EventSlashPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{19}
}
func (m *EventSlashPoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSlashPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSlashPoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSlashPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSlashPoint.Merge(m, src)
}
func (m *EventSlashPoint) XXX_Size() int {
	return m.Size()
}
func (m *EventSlashPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSlashPoint.DiscardUnknown(m)
}

var xxx_messageInfo_EventSlashPoint proto.InternalMessageInfo

func (m *EventSlashPoint) GetNodeAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.NodeAddress
	}
	return nil
}

func (m *EventSlashPoint) GetSlashPoints() int64 {
	if m != nil {
		return m.SlashPoints
	}
	return 0
}

func (m *EventSlashPoint) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type EventPoolBalanceChanged struct {
	PoolChange PoolMod `protobuf:"bytes,1,opt,name=pool_change,json=poolChange,proto3" json:"pool_change"`
	Reason     string  `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *EventPoolBalanceChanged) Reset()         { *m = EventPoolBalanceChanged{} }
func (m *EventPoolBalanceChanged) String() string { return proto.CompactTextString(m) }
func (*EventPoolBalanceChanged) ProtoMessage()    {}
func (*EventPoolBalanceChanged) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{20}
}
func (m *EventPoolBalanceChanged) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPoolBalanceChanged) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPoolBalanceChanged.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPoolBalanceChanged) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPoolBalanceChanged.Merge(m, src)
}
func (m *EventPoolBalanceChanged) XXX_Size() int {
	return m.Size()
}
func (m *EventPoolBalanceChanged) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPoolBalanceChanged.DiscardUnknown(m)
}

var xxx_messageInfo_EventPoolBalanceChanged proto.InternalMessageInfo

func (m *EventPoolBalanceChanged) GetPoolChange() PoolMod {
	if m != nil {
		return m.PoolChange
	}
	return PoolMod{}
}

func (m *EventPoolBalanceChanged) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type EventSwitch struct {
	ToAddress   github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=to_address,json=toAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"to_address,omitempty"`
	FromAddress gitlab_com_thorchain_thornode_common.Address  `protobuf:"bytes,2,opt,name=from_address,json=fromAddress,proto3,casttype=gitlab.com/thorchain/thornode/common.Address" json:"from_address,omitempty"`
	Burn        common.Coin                                   `protobuf:"bytes,3,opt,name=burn,proto3" json:"burn"`
}

func (m *EventSwitch) Reset()         { *m = EventSwitch{} }
func (m *EventSwitch) String() string { return proto.CompactTextString(m) }
func (*EventSwitch) ProtoMessage()    {}
func (*EventSwitch) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{21}
}
func (m *EventSwitch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSwitch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSwitch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSwitch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSwitch.Merge(m, src)
}
func (m *EventSwitch) XXX_Size() int {
	return m.Size()
}
func (m *EventSwitch) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSwitch.DiscardUnknown(m)
}

var xxx_messageInfo_EventSwitch proto.InternalMessageInfo

func (m *EventSwitch) GetToAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.ToAddress
	}
	return nil
}

func (m *EventSwitch) GetFromAddress() gitlab_com_thorchain_thornode_common.Address {
	if m != nil {
		return m.FromAddress
	}
	return ""
}

func (m *EventSwitch) GetBurn() common.Coin {
	if m != nil {
		return m.Burn
	}
	return common.Coin{}
}

func init() {
	proto.RegisterEnum("types.BondType", BondType_name, BondType_value)
	proto.RegisterType((*PoolMod)(nil), "types.PoolMod")
	proto.RegisterType((*EventSwap)(nil), "types.EventSwap")
	proto.RegisterType((*EventAddLiquidity)(nil), "types.EventAddLiquidity")
	proto.RegisterType((*EventWithdraw)(nil), "types.EventWithdraw")
	proto.RegisterType((*EventDonate)(nil), "types.EventDonate")
	proto.RegisterType((*EventPool)(nil), "types.EventPool")
	proto.RegisterType((*PoolAmt)(nil), "types.PoolAmt")
	proto.RegisterType((*EventRewards)(nil), "types.EventRewards")
	proto.RegisterType((*EventRefund)(nil), "types.EventRefund")
	proto.RegisterType((*EventBond)(nil), "types.EventBond")
	proto.RegisterType((*GasPool)(nil), "types.GasPool")
	proto.RegisterType((*EventGas)(nil), "types.EventGas")
	proto.RegisterType((*EventReserve)(nil), "types.EventReserve")
	proto.RegisterType((*EventSlash)(nil), "types.EventSlash")
	proto.RegisterType((*EventErrata)(nil), "types.EventErrata")
	proto.RegisterType((*EventFee)(nil), "types.EventFee")
	proto.RegisterType((*EventOutbound)(nil), "types.EventOutbound")
	proto.RegisterType((*EventTssKeygenMetric)(nil), "types.EventTssKeygenMetric")
	proto.RegisterType((*EventTssKeysignMetric)(nil), "types.EventTssKeysignMetric")
	proto.RegisterType((*EventSlashPoint)(nil), "types.EventSlashPoint")
	proto.RegisterType((*EventPoolBalanceChanged)(nil), "types.EventPoolBalanceChanged")
	proto.RegisterType((*EventSwitch)(nil), "types.EventSwitch")
}

func init() {
	proto.RegisterFile("thorchain/v1/x/thorchain/types/type_events.proto", fileDescriptor_00fa6e06b539fddf)
}

var fileDescriptor_00fa6e06b539fddf = []byte{
	// 1511 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0xdb, 0x6f, 0x13, 0xc7,
	0x1a, 0xcf, 0xfa, 0xee, 0xcf, 0x36, 0x24, 0x03, 0x9c, 0x63, 0x38, 0x52, 0x1c, 0xf6, 0xe8, 0x40,
	0xc2, 0x09, 0x09, 0xa4, 0x02, 0xd4, 0x4a, 0x7d, 0x88, 0x09, 0xd0, 0x40, 0xd2, 0xba, 0x1b, 0x53,
	0x24, 0xa4, 0x6a, 0xb5, 0xf6, 0x0c, 0xf6, 0x0a, 0x7b, 0xc6, 0xdd, 0x99, 0x4d, 0xec, 0xf7, 0x5e,
	0xde, 0xaa, 0xf6, 0xb1, 0xea, 0x5b, 0x5f, 0xaa, 0xf6, 0x2f, 0xe1, 0xa5, 0x12, 0x8f, 0x55, 0x55,
	0xb9, 0x55, 0x68, 0xff, 0x89, 0x3c, 0x55, 0x73, 0x59, 0x3b, 0xe1, 0x62, 0x39, 0x0b, 0x12, 0x2f,
	0xf1, 0xce, 0xce, 0x37, 0xbf, 0xf9, 0x2e, 0xbf, 0xef, 0xb2, 0x81, 0x2b, 0xa2, 0xcd, 0x82, 0x66,
	0xdb, 0xf3, 0xe9, 0xea, 0xee, 0xd5, 0xd5, 0xfe, 0xea, 0x78, 0x29, 0x06, 0x3d, 0xc2, 0xd5, 0x5f,
	0x97, 0xec, 0x12, 0x2a, 0xf8, 0x4a, 0x2f, 0x60, 0x82, 0xa1, 0xb4, 0xda, 0x38, 0xb7, 0x70, 0xe4,
	0x60, 0x93, 0x75, 0xbb, 0x8c, 0x9a, 0x1f, 0x2d, 0x78, 0xee, 0xfd, 0x69, 0xa0, 0x03, 0xc2, 0x49,
	0xb0, 0x4b, 0xdc, 0x26, 0xa3, 0x22, 0xf0, 0x1b, 0xa1, 0x60, 0x81, 0x39, 0xbe, 0x32, 0xcd, 0xf1,
	0x1e, 0x63, 0x1d, 0x23, 0x7f, 0xba, 0xc5, 0x5a, 0x4c, 0x3d, 0xae, 0xca, 0x27, 0xfd, 0xd6, 0xfe,
	0x32, 0x01, 0xd9, 0x1a, 0x63, 0x9d, 0x6d, 0x86, 0xd1, 0x12, 0xa4, 0x3d, 0xce, 0x89, 0x28, 0x5b,
	0x0b, 0xd6, 0x62, 0x61, 0xad, 0xb4, 0x62, 0xd4, 0x5d, 0x97, 0x2f, 0xab, 0xa9, 0x27, 0xc3, 0xca,
	0x8c, 0xa3, 0x25, 0xd0, 0x5d, 0xc8, 0x05, 0x21, 0x25, 0xae, 0xd7, 0x15, 0xe5, 0xc4, 0x82, 0xb5,
	0x98, 0xaf, 0xae, 0xca, 0xed, 0xdf, 0x86, 0x95, 0x8b, 0x2d, 0x5f, 0xb4, 0xc3, 0x86, 0x3c, 0xbb,
	0xda, 0x64, 0xbc, 0xcb, 0xb8, 0xf9, 0xb9, 0xcc, 0xf1, 0x63, 0xad, 0xda, 0xca, 0x7d, 0x9f, 0x0a,
	0x27, 0x2b, 0x01, 0xd6, 0xbb, 0x02, 0x9d, 0x8d, 0xb0, 0x30, 0x2e, 0x27, 0x17, 0xac, 0xc5, 0x9c,
	0xd9, 0xc2, 0x18, 0x6d, 0x41, 0x5e, 0xdd, 0xa7, 0xee, 0x49, 0xc5, 0xbb, 0x27, 0xa7, 0x10, 0xe4,
	0x45, 0xff, 0x19, 0xa1, 0x61, 0x5c, 0x4e, 0xab, 0x9b, 0xcc, 0x26, 0xc6, 0xf6, 0xdf, 0x29, 0xc8,
	0xdf, 0x92, 0x71, 0xdc, 0xd9, 0xf3, 0x7a, 0xe8, 0x22, 0xa4, 0xa4, 0xeb, 0x26, 0x79, 0x42, 0x09,
	0xa0, 0x1a, 0x14, 0xf8, 0x9e, 0xd7, 0x73, 0x85, 0x17, 0xb4, 0x48, 0x6c, 0x5f, 0x80, 0xc4, 0xa8,
	0x2b, 0x08, 0x69, 0xb3, 0x42, 0xe4, 0x1d, 0xbf, 0xa7, 0xfc, 0x11, 0xc7, 0x66, 0x89, 0xb0, 0xd3,
	0xf1, 0x7b, 0xa8, 0x0e, 0xa5, 0x8e, 0xff, 0x59, 0xe8, 0x63, 0x5f, 0x0c, 0xdc, 0x47, 0x84, 0xc4,
	0xf5, 0x62, 0x71, 0x84, 0x72, 0x9b, 0x10, 0xd4, 0x80, 0x33, 0x47, 0x50, 0x5d, 0x9f, 0xba, 0x32,
	0x66, 0xca, 0xab, 0x31, 0xd0, 0xd1, 0x61, 0xf4, 0x4d, 0xea, 0x84, 0x94, 0xa0, 0xff, 0x41, 0xda,
	0xa7, 0xae, 0xe8, 0x97, 0x33, 0x2a, 0x06, 0x10, 0xc5, 0xa0, 0xde, 0x8f, 0x02, 0xe0, 0xd3, 0x7a,
	0x1f, 0x2d, 0x41, 0x96, 0x85, 0xc2, 0x15, 0x7d, 0x5e, 0xce, 0xbe, 0x42, 0x30, 0xc3, 0x42, 0x51,
	0xef, 0x73, 0x74, 0x15, 0x80, 0x74, 0x7d, 0xe1, 0x6a, 0x92, 0xe7, 0x94, 0x74, 0x31, 0x92, 0xbe,
	0xc9, 0x7c, 0x6a, 0xe4, 0xf3, 0x52, 0x4a, 0x85, 0x5a, 0x85, 0x77, 0x40, 0x45, 0xdb, 0x0d, 0xa9,
	0x2f, 0x78, 0x39, 0x1f, 0x37, 0xbc, 0x12, 0xe3, 0xbe, 0x84, 0xb0, 0xbf, 0x4f, 0xc3, 0x9c, 0xe2,
	0xd9, 0x3a, 0xc6, 0x5b, 0x91, 0xd5, 0xd3, 0xf3, 0xed, 0x13, 0x38, 0xd1, 0x0b, 0xd8, 0xae, 0x8f,
	0x49, 0x60, 0x74, 0x8a, 0x49, 0xb9, 0x52, 0x04, 0xa3, 0xd4, 0x42, 0x3b, 0x50, 0x8c, 0x92, 0x30,
	0x20, 0x9c, 0x1b, 0xe2, 0x5d, 0x39, 0x18, 0x56, 0x96, 0x5b, 0xbe, 0xe8, 0x78, 0x1a, 0xf1, 0x50,
	0x8d, 0x69, 0xb3, 0x80, 0x32, 0x4c, 0xa2, 0x92, 0xb6, 0xae, 0xcf, 0x39, 0x05, 0x93, 0xba, 0x72,
	0x21, 0xbd, 0x67, 0xaa, 0x04, 0x0b, 0x69, 0xec, 0x04, 0x06, 0x5d, 0x28, 0x24, 0x04, 0x72, 0xa0,
	0x18, 0x15, 0x04, 0x05, 0x19, 0x93, 0x6f, 0x05, 0x53, 0x13, 0x14, 0xe6, 0x03, 0x50, 0x37, 0xb8,
	0xa2, 0xef, 0xfa, 0x58, 0xb1, 0x2d, 0x5f, 0x7d, 0x77, 0x7f, 0x58, 0xc9, 0x49, 0x1a, 0xd6, 0xfb,
	0x9b, 0x1b, 0x07, 0xc3, 0xca, 0xd2, 0x54, 0x4e, 0x90, 0xc2, 0x8e, 0x2a, 0x66, 0xf5, 0xfe, 0x26,
	0x46, 0x0f, 0x41, 0xdf, 0x63, 0x90, 0xb3, 0x0a, 0xf9, 0xbd, 0xfd, 0x61, 0x25, 0xaf, 0xe2, 0x7a,
	0x7c, 0x68, 0x5d, 0xbe, 0x14, 0xf6, 0x7d, 0x28, 0x8d, 0x6a, 0x99, 0x0a, 0x58, 0x2e, 0x66, 0xc0,
	0x8a, 0x51, 0x05, 0x94, 0x2b, 0xfb, 0xc7, 0x14, 0x94, 0x14, 0x3b, 0x1f, 0xf8, 0xa2, 0x8d, 0x03,
	0x6f, 0xef, 0xed, 0x33, 0xf3, 0x3c, 0x14, 0x1b, 0x1e, 0xf7, 0xb9, 0xdb, 0x63, 0x3e, 0x15, 0x9a,
	0x99, 0x49, 0xa7, 0xa0, 0xde, 0xd5, 0xd4, 0x2b, 0xdd, 0x26, 0x06, 0xdd, 0x2e, 0x11, 0xc1, 0x40,
	0xb1, 0xac, 0x58, 0x5d, 0x31, 0xb7, 0x5e, 0x98, 0xe2, 0xd6, 0x0d, 0xd2, 0x74, 0xc6, 0x00, 0xe3,
	0xc2, 0x93, 0x9e, 0x58, 0x78, 0x3e, 0x3c, 0x52, 0x4d, 0x32, 0xf1, 0x6c, 0x3d, 0x54, 0x6a, 0xb6,
	0x40, 0x2d, 0x74, 0x1d, 0xcd, 0xc6, 0xac, 0xfb, 0x12, 0x41, 0x55, 0x4f, 0x17, 0x4e, 0xf9, 0xdd,
	0x9e, 0xdb, 0x61, 0x9c, 0xbb, 0xb2, 0xd3, 0x93, 0xa6, 0xf0, 0x19, 0x35, 0x2c, 0x39, 0x36, 0xee,
	0x9c, 0xdf, 0xed, 0x6d, 0x31, 0xce, 0x6b, 0x23, 0x24, 0xfb, 0x53, 0x28, 0x28, 0xa2, 0x6c, 0x30,
	0xea, 0x09, 0x32, 0x3d, 0x4d, 0x46, 0xde, 0x4d, 0x4c, 0xf2, 0xae, 0xed, 0x9a, 0x6e, 0x2c, 0x67,
	0x93, 0xe9, 0xc1, 0x97, 0x20, 0xb3, 0x23, 0x3c, 0x11, 0x6a, 0xee, 0x9d, 0x58, 0x9b, 0x5b, 0xd1,
	0x46, 0x48, 0x14, 0xbd, 0xe1, 0x18, 0x01, 0x7b, 0x4b, 0xcf, 0x3d, 0x72, 0x2e, 0x38, 0xc6, 0xdc,
	0xf3, 0x2f, 0xc8, 0x98, 0xca, 0x93, 0x50, 0x34, 0x34, 0x2b, 0xfb, 0x3b, 0x0b, 0x8a, 0x4a, 0x5f,
	0x87, 0xec, 0x79, 0x01, 0x56, 0xa5, 0xaf, 0xc1, 0x28, 0x76, 0x03, 0xb5, 0x56, 0xc8, 0x71, 0x4a,
	0x9f, 0xc4, 0xd0, 0x90, 0xe8, 0x06, 0x14, 0xa5, 0x8d, 0x06, 0x51, 0x5a, 0x98, 0x5c, 0x2c, 0xac,
	0x9d, 0x38, 0x64, 0xe1, 0x7a, 0x37, 0xd2, 0xb6, 0x20, 0x25, 0x8d, 0x2a, 0xf6, 0x17, 0x96, 0x09,
	0x95, 0x43, 0x1e, 0x85, 0x14, 0x23, 0x04, 0xa9, 0x26, 0xc3, 0x44, 0xe9, 0x54, 0x72, 0xd4, 0xb3,
	0xb4, 0x2b, 0x20, 0x1e, 0x67, 0x54, 0x27, 0xad, 0x63, 0x56, 0xe3, 0x68, 0x25, 0x27, 0xe6, 0xc2,
	0x7f, 0x21, 0x19, 0xcd, 0x16, 0x85, 0xb5, 0x42, 0x24, 0x74, 0x9b, 0x10, 0x23, 0x25, 0x77, 0xed,
	0x9f, 0x2c, 0x13, 0xd3, 0x2a, 0xa3, 0x18, 0xdd, 0x19, 0x79, 0x32, 0xa6, 0x6f, 0xcc, 0x71, 0xb4,
	0x0c, 0x79, 0xe5, 0x69, 0xb9, 0x65, 0xc2, 0x7e, 0xd2, 0x38, 0x45, 0x5e, 0x54, 0x1f, 0xf4, 0x88,
	0x93, 0x6b, 0x98, 0x27, 0x69, 0x90, 0xac, 0xc6, 0xf4, 0xd5, 0x06, 0x89, 0xfe, 0x26, 0xb5, 0xff,
	0xb2, 0x20, 0x7b, 0xc7, 0xe3, 0x35, 0x4d, 0xaa, 0xb7, 0x32, 0x16, 0x1f, 0x99, 0x7d, 0x93, 0xaf,
	0x3b, 0xfb, 0x9e, 0x86, 0x74, 0x73, 0xd4, 0x84, 0x93, 0x8e, 0x5e, 0xd8, 0xd7, 0x21, 0xa7, 0x22,
	0x72, 0xc7, 0xe3, 0xe8, 0x12, 0xa4, 0x25, 0x6b, 0x78, 0xd9, 0x3a, 0x42, 0x2c, 0xe3, 0x85, 0xc8,
	0x4e, 0x25, 0x62, 0x7f, 0x35, 0xa6, 0xbb, 0xfa, 0x3c, 0x41, 0x35, 0x38, 0xf5, 0x92, 0x2f, 0x15,
	0xe3, 0xb1, 0xb3, 0x06, 0xca, 0x08, 0xdf, 0x1c, 0x0b, 0x18, 0x54, 0x14, 0xbc, 0xb0, 0x33, 0x6d,
	0x9d, 0xa0, 0x00, 0x7a, 0x6a, 0xef, 0x78, 0xbc, 0x3d, 0x7d, 0xa1, 0xb8, 0x01, 0x45, 0x2e, 0x4f,
	0xb8, 0xa3, 0x6c, 0x9e, 0x90, 0x4c, 0x4a, 0x52, 0x0f, 0x0b, 0xf6, 0xb7, 0x51, 0x32, 0xdd, 0x0a,
	0x02, 0x4f, 0x78, 0xe8, 0xae, 0xe6, 0x53, 0x94, 0xe1, 0xd7, 0xf6, 0x87, 0x95, 0xd4, 0xf1, 0x1b,
	0xbb, 0x24, 0x1d, 0x46, 0xd7, 0xa3, 0x08, 0xbc, 0xa8, 0xcd, 0x36, 0xc3, 0xd5, 0x59, 0xa9, 0xcd,
	0xcf, 0x7f, 0x54, 0x72, 0xe6, 0x05, 0x8f, 0xa2, 0xf1, 0x8b, 0x65, 0xc2, 0x28, 0x47, 0xf3, 0x37,
	0xa9, 0x90, 0x49, 0xeb, 0xc4, 0xa4, 0xb4, 0x7e, 0x7e, 0x44, 0x4e, 0xbe, 0xfe, 0x88, 0xfc, 0xb9,
	0x65, 0x86, 0x90, 0x8f, 0x42, 0xd1, 0x60, 0xb2, 0x64, 0x7d, 0x0c, 0x39, 0x45, 0x86, 0xb1, 0x5d,
	0x37, 0xf6, 0x87, 0x95, 0xcc, 0x26, 0x3d, 0xbe, 0x65, 0x19, 0x49, 0x9b, 0x4d, 0x8c, 0x16, 0x20,
	0x31, 0x81, 0x5c, 0x09, 0xd1, 0xb7, 0xbf, 0xb6, 0xe0, 0xb4, 0x52, 0xa3, 0xce, 0xf9, 0x3d, 0x32,
	0x68, 0x11, 0xba, 0x4d, 0x44, 0xe0, 0x37, 0xd1, 0x07, 0x90, 0xed, 0x85, 0x0d, 0xf7, 0x31, 0x19,
	0x44, 0xb5, 0xeb, 0x60, 0x58, 0xf9, 0xff, 0x54, 0x2a, 0xd4, 0xc2, 0xc6, 0x3d, 0x32, 0x70, 0x32,
	0x3d, 0xf5, 0x8b, 0x96, 0x01, 0x75, 0x09, 0xf6, 0x3d, 0xea, 0xe2, 0x30, 0xf0, 0x64, 0x5f, 0x75,
	0xbb, 0xdc, 0xb4, 0x96, 0x59, 0xbd, 0xb3, 0x61, 0x36, 0xb6, 0xb9, 0xe4, 0xde, 0x99, 0x43, 0x0a,
	0x71, 0xbf, 0x15, 0x69, 0xf4, 0x26, 0x83, 0x7e, 0x3c, 0x9d, 0x7e, 0xb0, 0xe0, 0xe4, 0x38, 0x01,
	0xd5, 0x3c, 0x86, 0xea, 0x50, 0x94, 0xd8, 0xa3, 0xd1, 0xd4, 0x52, 0x13, 0xd9, 0xd5, 0x83, 0x61,
	0xe5, 0xf2, 0x14, 0x74, 0x58, 0x6f, 0x36, 0x47, 0x1f, 0x13, 0x12, 0x26, 0xfa, 0x98, 0x38, 0x1f,
	0xa5, 0xac, 0x99, 0x03, 0xb5, 0x46, 0x3a, 0x39, 0xcd, 0x1c, 0x38, 0xee, 0x62, 0xc9, 0xc3, 0x5d,
	0xcc, 0x6e, 0xc3, 0xbf, 0x47, 0xc3, 0x44, 0xd5, 0xeb, 0x78, 0xb4, 0x49, 0x6e, 0xb6, 0x3d, 0xda,
	0x22, 0x18, 0x5d, 0x03, 0xd5, 0x2b, 0xdd, 0xa6, 0x5a, 0x9b, 0xc2, 0xf1, 0x7c, 0xe6, 0x69, 0x4e,
	0x80, 0x14, 0xd4, 0xe7, 0x5e, 0xd5, 0x2f, 0xed, 0xdf, 0xa3, 0xf2, 0xb0, 0xb3, 0xe7, 0x8b, 0x66,
	0x1b, 0xd5, 0x00, 0x04, 0x7b, 0x7d, 0x47, 0xe4, 0x05, 0x8b, 0xdc, 0xb0, 0x03, 0xc5, 0x47, 0x01,
	0xeb, 0x8e, 0x30, 0x13, 0x71, 0x3f, 0xd4, 0x24, 0x4a, 0x04, 0x7a, 0x01, 0x52, 0x8d, 0x30, 0x88,
	0x9a, 0xe2, 0xcb, 0xbe, 0x89, 0xd5, 0xfe, 0xa5, 0x65, 0xc8, 0x45, 0x3d, 0x15, 0x95, 0x4c, 0xdf,
	0xed, 0x79, 0x3e, 0x9e, 0x9d, 0x41, 0x73, 0x50, 0x32, 0x03, 0x8f, 0x08, 0x03, 0x4a, 0xf0, 0xac,
	0x55, 0xdd, 0x7c, 0xb2, 0x3f, 0x6f, 0x3d, 0xdd, 0x9f, 0xb7, 0xfe, 0xdc, 0x9f, 0xb7, 0xbe, 0x79,
	0x36, 0x3f, 0xf3, 0xf4, 0xd9, 0xfc, 0xcc, 0xaf, 0xcf, 0xe6, 0x67, 0x1e, 0xae, 0x4e, 0x56, 0xf5,
	0x85, 0x7f, 0x66, 0x35, 0x32, 0xea, 0xbf, 0x55, 0xef, 0xfc, 0x13, 0x00, 0x00, 0xff, 0xff, 0x8e,
	0x94, 0x3e, 0x36, 0x8f, 0x13, 0x00, 0x00,
}

func (m *PoolMod) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolMod) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolMod) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AssetAdd {
		i--
		if m.AssetAdd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.AssetAmt.Size()
		i -= size
		if _, err := m.AssetAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.RuneAdd {
		i--
		if m.RuneAdd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.RuneAmt.Size()
		i -= size
		if _, err := m.RuneAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventSwap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSwap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSwap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.SynthUnits.Size()
		i -= size
		if _, err := m.SynthUnits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.EmitAsset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.OutTxs.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.InTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.LiquidityFeeInRune.Size()
		i -= size
		if _, err := m.LiquidityFeeInRune.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.LiquidityFee.Size()
		i -= size
		if _, err := m.LiquidityFee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.SwapSlip.Size()
		i -= size
		if _, err := m.SwapSlip.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.SwapTarget.Size()
		i -= size
		if _, err := m.SwapTarget.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Pool.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventAddLiquidity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAddLiquidity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAddLiquidity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AssetAddress) > 0 {
		i -= len(m.AssetAddress)
		copy(dAtA[i:], m.AssetAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetAddress)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.AssetTxID) > 0 {
		i -= len(m.AssetTxID)
		copy(dAtA[i:], m.AssetTxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetTxID)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.RuneTxID) > 0 {
		i -= len(m.RuneTxID)
		copy(dAtA[i:], m.RuneTxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.RuneTxID)))
		i--
		dAtA[i] = 0x32
	}
	{
		size := m.AssetAmount.Size()
		i -= size
		if _, err := m.AssetAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.RuneAmount.Size()
		i -= size
		if _, err := m.RuneAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.RuneAddress) > 0 {
		i -= len(m.RuneAddress)
		copy(dAtA[i:], m.RuneAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.RuneAddress)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.ProviderUnits.Size()
		i -= size
		if _, err := m.ProviderUnits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Pool.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.ImpLossProtection.Size()
		i -= size
		if _, err := m.ImpLossProtection.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.EmitRune.Size()
		i -= size
		if _, err := m.EmitRune.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.EmitAsset.Size()
		i -= size
		if _, err := m.EmitAsset.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.InTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.Asymmetry.Size()
		i -= size
		if _, err := m.Asymmetry.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.BasisPoints != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.BasisPoints))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.ProviderUnits.Size()
		i -= size
		if _, err := m.ProviderUnits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Pool.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventDonate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventDonate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventDonate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.InTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Pool.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Pool.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PoolAmt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolAmt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolAmt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Amount != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventRewards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventRewards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventRewards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PoolRewards) > 0 {
		for iNdEx := len(m.PoolRewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PoolRewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypeEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size := m.BondReward.Size()
		i -= size
		if _, err := m.BondReward.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventRefund) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventRefund) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventRefund) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.InTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventBond) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBond) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBond) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.TxIn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.BondType != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.BondType))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GasPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GasPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GasPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.AssetAmt.Size()
		i -= size
		if _, err := m.AssetAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.RuneAmt.Size()
		i -= size
		if _, err := m.RuneAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventGas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventGas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventGas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for iNdEx := len(m.Pools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypeEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EventReserve) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventReserve) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventReserve) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.InTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ReserveContributor.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventSlash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSlash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSlash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SlashAmount) > 0 {
		for iNdEx := len(m.SlashAmount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SlashAmount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypeEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Pool.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventErrata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventErrata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventErrata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for iNdEx := len(m.Pools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypeEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventFee) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventFee) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventFee) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.SynthUnits.Size()
		i -= size
		if _, err := m.SynthUnits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventOutbound) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOutbound) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOutbound) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Tx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.InTxID) > 0 {
		i -= len(m.InTxID)
		copy(dAtA[i:], m.InTxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.InTxID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventTssKeygenMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTssKeygenMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTssKeygenMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MedianDurationMs != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.MedianDurationMs))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventTssKeysignMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTssKeysignMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTssKeysignMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MedianDurationMs != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.MedianDurationMs))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSlashPoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSlashPoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSlashPoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SlashPoints != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.SlashPoints))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NodeAddress) > 0 {
		i -= len(m.NodeAddress)
		copy(dAtA[i:], m.NodeAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.NodeAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventPoolBalanceChanged) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPoolBalanceChanged) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPoolBalanceChanged) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.PoolChange.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventSwitch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSwitch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSwitch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Burn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.FromAddress) > 0 {
		i -= len(m.FromAddress)
		copy(dAtA[i:], m.FromAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.FromAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ToAddress) > 0 {
		i -= len(m.ToAddress)
		copy(dAtA[i:], m.ToAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.ToAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypeEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypeEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PoolMod) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.RuneAmt.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.RuneAdd {
		n += 2
	}
	l = m.AssetAmt.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.AssetAdd {
		n += 2
	}
	return n
}

func (m *EventSwap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.SwapTarget.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.SwapSlip.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.LiquidityFee.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.LiquidityFeeInRune.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.InTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.OutTxs.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.EmitAsset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.SynthUnits.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventAddLiquidity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.ProviderUnits.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.RuneAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.RuneAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.AssetAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.RuneTxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.AssetTxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.AssetAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.ProviderUnits.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.BasisPoints != 0 {
		n += 1 + sovTypeEvents(uint64(m.BasisPoints))
	}
	l = m.Asymmetry.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.InTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.EmitAsset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.EmitRune.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.ImpLossProtection.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventDonate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.InTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.Status != 0 {
		n += 1 + sovTypeEvents(uint64(m.Status))
	}
	return n
}

func (m *PoolAmt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.Amount != 0 {
		n += 1 + sovTypeEvents(uint64(m.Amount))
	}
	return n
}

func (m *EventRewards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BondReward.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if len(m.PoolRewards) > 0 {
		for _, e := range m.PoolRewards {
			l = e.Size()
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	return n
}

func (m *EventRefund) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovTypeEvents(uint64(m.Code))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.InTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Fee.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventBond) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.BondType != 0 {
		n += 1 + sovTypeEvents(uint64(m.BondType))
	}
	l = m.TxIn.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *GasPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.RuneAmt.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.AssetAmt.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.Count != 0 {
		n += 1 + sovTypeEvents(uint64(m.Count))
	}
	return n
}

func (m *EventGas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for _, e := range m.Pools {
			l = e.Size()
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	return n
}

func (m *EventReserve) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ReserveContributor.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.InTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventSlash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if len(m.SlashAmount) > 0 {
		for _, e := range m.SlashAmount {
			l = e.Size()
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	return n
}

func (m *EventErrata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if len(m.Pools) > 0 {
		for _, e := range m.Pools {
			l = e.Size()
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	return n
}

func (m *EventFee) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Fee.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.SynthUnits.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventOutbound) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InTxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Tx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventTssKeygenMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.MedianDurationMs != 0 {
		n += 1 + sovTypeEvents(uint64(m.MedianDurationMs))
	}
	return n
}

func (m *EventTssKeysignMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.MedianDurationMs != 0 {
		n += 1 + sovTypeEvents(uint64(m.MedianDurationMs))
	}
	return n
}

func (m *EventSlashPoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.SlashPoints != 0 {
		n += 1 + sovTypeEvents(uint64(m.SlashPoints))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventPoolBalanceChanged) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.PoolChange.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventSwitch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ToAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.FromAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Burn.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func sovTypeEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypeEvents(x uint64) (n int) {
	return sovTypeEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PoolMod) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolMod: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolMod: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RuneAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAdd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RuneAdd = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AssetAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAdd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AssetAdd = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSwap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSwap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSwap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapTarget", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SwapTarget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapSlip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SwapSlip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LiquidityFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityFeeInRune", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LiquidityFeeInRune.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutTxs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OutTxs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmitAsset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EmitAsset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SynthUnits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SynthUnits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventAddLiquidity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAddLiquidity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAddLiquidity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderUnits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProviderUnits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuneAddress = gitlab_com_thorchain_thornode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RuneAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AssetAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneTxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuneTxID = gitlab_com_thorchain_thornode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetTxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetTxID = gitlab_com_thorchain_thornode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetAddress = gitlab_com_thorchain_thornode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderUnits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProviderUnits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasisPoints", wireType)
			}
			m.BasisPoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BasisPoints |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asymmetry", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asymmetry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmitAsset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EmitAsset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmitRune", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EmitRune.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImpLossProtection", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ImpLossProtection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventDonate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventDonate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventDonate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= PoolStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolAmt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolAmt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolAmt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventRewards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventRewards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventRewards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondReward", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BondReward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolRewards = append(m.PoolRewards, PoolAmt{})
			if err := m.PoolRewards[len(m.PoolRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventRefund) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventRefund: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventRefund: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBond) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBond: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBond: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondType", wireType)
			}
			m.BondType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BondType |= BondType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GasPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GasPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GasPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RuneAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AssetAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventGas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventGas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventGas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pools = append(m.Pools, GasPool{})
			if err := m.Pools[len(m.Pools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventReserve) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventReserve: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventReserve: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReserveContributor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReserveContributor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSlash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSlash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSlash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlashAmount = append(m.SlashAmount, PoolAmt{})
			if err := m.SlashAmount[len(m.SlashAmount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventErrata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventErrata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventErrata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_thorchain_thornode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pools = append(m.Pools, PoolMod{})
			if err := m.Pools[len(m.Pools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventFee) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventFee: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventFee: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_thorchain_thornode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SynthUnits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SynthUnits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventOutbound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOutbound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOutbound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InTxID = gitlab_com_thorchain_thornode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Tx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTssKeygenMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTssKeygenMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTssKeygenMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = gitlab_com_thorchain_thornode_common.PubKey(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MedianDurationMs", wireType)
			}
			m.MedianDurationMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MedianDurationMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTssKeysignMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTssKeysignMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTssKeysignMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_thorchain_thornode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MedianDurationMs", wireType)
			}
			m.MedianDurationMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MedianDurationMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSlashPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSlashPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSlashPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddress = append(m.NodeAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.NodeAddress == nil {
				m.NodeAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashPoints", wireType)
			}
			m.SlashPoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashPoints |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPoolBalanceChanged) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPoolBalanceChanged: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPoolBalanceChanged: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PoolChange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSwitch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSwitch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSwitch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToAddress = append(m.ToAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.ToAddress == nil {
				m.ToAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddress = gitlab_com_thorchain_thornode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Burn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Burn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypeEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypeEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypeEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypeEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypeEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypeEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypeEvents = fmt.Errorf("proto: unexpected end of group")
)
